<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Character Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      background: #fff;
    }

    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 10;
    }

    .header {
      padding: 20px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .score-box {
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(10px);
      padding: 12px 20px;
      border-radius: 15px;
      color: white;
    }

    .score-label {
      font-size: 12px;
      opacity: 0.7;
    }

    .score-value {
      font-size: 28px;
      font-weight: bold;
    }

    .status-box {
      background: rgba(34,197,94,0.3);
      backdrop-filter: blur(10px);
      padding: 8px 16px;
      border-radius: 12px;
      color: white;
      font-size: 14px;
    }

    .message {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(10px);
      padding: 12px 24px;
      border-radius: 12px;
      color: white;
      font-size: 14px;
      max-width: 80%;
      text-align: center;
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      padding: 0 20px;
      pointer-events: auto;
      display: flex;
      gap: 15px;
      align-items: flex-end;
    }

    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      flex: 1;
      max-width: 300px;
    }

    .control-btn {
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(10px);
      border: none;
      color: white;
      font-size: 18px;
      padding: 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.15s;
      touch-action: manipulation;
      user-select: none;
    }

    .control-btn:active {
      background: rgba(255,255,255,0.4);
      transform: scale(0.95);
    }

    .jump-btn {
      background: linear-gradient(135deg, #fbbf24, #f97316);
      padding: 20px 28px;
      border-radius: 50%;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    }

    .jump-btn:active {
      transform: scale(0.9);
    }

    .stop-btn {
      background: rgba(239,68,68,0.8);
      padding: 16px 24px;
      border-radius: 12px;
      font-weight: bold;
    }

    .start-section {
      position: absolute;
      bottom: 30px;
      left: 30px;
      right: 30px;
      pointer-events: auto;
    }

    .start-btn {
      width: 100%;
      background: linear-gradient(to right, #3b82f6, #8b5cf6);
      border: none;
      color: white;
      font-size: 18px;
      font-weight: bold;
      padding: 24px;
      border-radius: 20px;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      transition: transform 0.2s;
    }

    .start-btn:hover {
      transform: scale(1.02);
    }

    .instructions {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(20px);
      padding: 40px;
      border-radius: 24px;
      max-width: 500px;
      color: white;
    }

    .instructions h1 {
      font-size: 32px;
      margin-bottom: 20px;
      text-align: center;
    }

    .instructions p {
      margin: 12px 0;
      line-height: 1.6;
    }

    .error-screen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #1e1b4b, #581c87);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .error-box {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(20px);
      padding: 40px;
      border-radius: 24px;
      max-width: 500px;
      color: white;
      text-align: center;
    }

    .error-icon {
      font-size: 64px;
      margin-bottom: 20px;
    }

    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 48px;
      height: 48px;
      border: 4px solid #22c55e;
      border-radius: 50%;
      opacity: 0.5;
      animation: pulse 2s infinite;
    }

    .crosshair::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.1); }
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui-overlay">
    <div class="header">
      <div class="score-box">
        <div class="score-label">Distance</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="status-box hidden" id="status">‚úì Character Active</div>
    </div>

    <div class="message hidden" id="message"></div>

    <div class="controls hidden" id="controls">
      <div class="dpad">
        <div></div>
        <button class="control-btn" id="btn-forward">‚ñ≤</button>
        <div></div>
        <button class="control-btn" id="btn-left">‚óÄ</button>
        <button class="control-btn" id="btn-backward">‚ñº</button>
        <button class="control-btn" id="btn-right">‚ñ∂</button>
      </div>
      <button class="control-btn jump-btn" id="btn-jump">JUMP</button>
      <button class="control-btn stop-btn" id="btn-stop">Stop</button>
    </div>

    <div class="start-section" id="start-section">
      <button class="start-btn" id="btn-start">‚ñ∂ Start AR Character Game</button>
    </div>

    <div class="instructions" id="instructions">
      <h1>AR Character Game</h1>
      <p>üéÆ Control a 3D character in AR</p>
      <p>üì± Point camera at floor/table</p>
      <p>ü§ñ Character auto-places on surface</p>
      <p>‚¨ÜÔ∏è Use D-pad to move around</p>
      <p>ü¶ò Jump button to leap</p>
      <p>üß± Collides with real objects</p>
      <p>üèÉ Walk on detected surfaces</p>
    </div>

    <div class="crosshair hidden" id="crosshair"></div>
  </div>

  <div class="error-screen hidden" id="error-screen">
    <div class="error-box">
      <div class="error-icon">‚ö†Ô∏è</div>
      <h2 style="font-size: 24px; margin-bottom: 16px;">AR Not Supported</h2>
      <p style="margin-bottom: 12px;">WebAR requires a compatible device and browser. Please try:</p>
      <ul style="text-align: left; margin-left: 20px; line-height: 1.8;">
        <li>Android phone with ARCore support</li>
        <li>Chrome or Edge browser</li>
        <li>HTTPS connection</li>
      </ul>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Game state
    const state = {
      arActive: false,
      characterPlaced: false,
      score: 0,
      character: {
        x: 0, y: 0, z: -1,
        vx: 0, vy: 0, vz: 0,
        rotation: 0,
        size: 0.15,
        isJumping: false,
        onGround: true,
        mesh: null
      },
      surfaces: [],
      surfaceMeshes: [],
      keysPressed: {},
      session: null,
      renderer: null,
      scene: null,
      camera: null,
      animationFrame: null,
      hitTestSource: null,
      referenceSpace: null
    };

    // DOM elements
    const elements = {
      container: document.getElementById('container'),
      score: document.getElementById('score'),
      message: document.getElementById('message'),
      status: document.getElementById('status'),
      controls: document.getElementById('controls'),
      startSection: document.getElementById('start-section'),
      instructions: document.getElementById('instructions'),
      errorScreen: document.getElementById('error-screen'),
      crosshair: document.getElementById('crosshair'),
      btnStart: document.getElementById('btn-start'),
      btnStop: document.getElementById('btn-stop'),
      btnJump: document.getElementById('btn-jump'),
      btnForward: document.getElementById('btn-forward'),
      btnBackward: document.getElementById('btn-backward'),
      btnLeft: document.getElementById('btn-left'),
      btnRight: document.getElementById('btn-right')
    };

    // Initialize Three.js
    function initThree() {
      state.scene = new THREE.Scene();
      state.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
      
      state.renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true
      });
      state.renderer.setPixelRatio(window.devicePixelRatio);
      state.renderer.setSize(window.innerWidth, window.innerHeight);
      state.renderer.xr.enabled = true;
      elements.container.appendChild(state.renderer.domElement);

      // Add lighting
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      state.scene.add(light);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(1, 2, 1);
      state.scene.add(directionalLight);

      // Create character (cute robot-like character)
      createCharacter();
    }

    function createCharacter() {
      const character = new THREE.Group();
      
      // Body (green cube)
      const bodyGeometry = new THREE.BoxGeometry(0.12, 0.15, 0.1);
      const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x22c55e,
        metalness: 0.3,
        roughness: 0.7
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.075;
      character.add(body);

      // Head (smaller cube on top)
      const headGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
      const headMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x10b981,
        metalness: 0.3,
        roughness: 0.7
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 0.19;
      character.add(head);

      // Eyes (white spheres)
      const eyeGeometry = new THREE.SphereGeometry(0.015, 8, 8);
      const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.02, 0.2, 0.04);
      character.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.02, 0.2, 0.04);
      character.add(rightEye);

      // Arms
      const armGeometry = new THREE.BoxGeometry(0.04, 0.12, 0.04);
      const armMaterial = new THREE.MeshStandardMaterial({ color: 0x22c55e });
      
      const leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.08, 0.08, 0);
      character.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.08, 0.08, 0);
      character.add(rightArm);

      // Legs
      const legGeometry = new THREE.BoxGeometry(0.04, 0.08, 0.04);
      const legMaterial = new THREE.MeshStandardMaterial({ color: 0x10b981 });
      
      const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.03, -0.04, 0);
      character.add(leftLeg);
      
      const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.03, -0.04, 0);
      character.add(rightLeg);

      character.visible = false;
      state.character.mesh = character;
      state.scene.add(character);
    }

    // Check AR support
    async function checkARSupport() {
      if (!navigator.xr) {
        showError();
        return false;
      }

      try {
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!supported) {
          showError();
          return false;
        }
        return true;
      } catch (err) {
        showError();
        return false;
      }
    }

    function showError() {
      elements.errorScreen.classList.remove('hidden');
      elements.startSection.classList.add('hidden');
      elements.instructions.classList.add('hidden');
    }

    function showMessage(text, duration = 0) {
      elements.message.textContent = text;
      elements.message.classList.remove('hidden');
      if (duration > 0) {
        setTimeout(() => elements.message.classList.add('hidden'), duration);
      }
    }

    // Start AR session
    async function startAR() {
      try {
        state.session = await navigator.xr.requestSession('immersive-ar', {
          requiredFeatures: ['hit-test', 'dom-overlay'],
          domOverlay: { root: document.body }
        });

        state.session.updateRenderState({
          baseLayer: new XRWebGLLayer(state.session, state.renderer.getContext())
        });

        state.referenceSpace = await state.session.requestReferenceSpace('local');
        const viewerSpace = await state.session.requestReferenceSpace('viewer');
        state.hitTestSource = await state.session.requestHitTestSource({ space: viewerSpace });

        state.renderer.xr.setReferenceSpaceType('local');
        state.renderer.xr.setSession(state.session);

        state.arActive = true;
        elements.startSection.classList.add('hidden');
        elements.instructions.classList.add('hidden');
        elements.crosshair.classList.remove('hidden');
        showMessage('Point at a surface to place your character!');

        state.session.addEventListener('end', () => {
          endAR();
        });

        state.renderer.setAnimationLoop(onXRFrame);
      } catch (err) {
        showMessage('Failed to start AR: ' + err.message);
        console.error(err);
      }
    }

    // XR Frame loop
    function onXRFrame(timestamp, frame) {
      if (!frame || !state.session) return;

      const pose = frame.getViewerPose(state.referenceSpace);
      if (!pose) return;

      // Hit testing for surface detection
      if (state.hitTestSource) {
        const hitTestResults = frame.getHitTestResults(state.hitTestSource);
        if (hitTestResults.length > 0 && !state.characterPlaced) {
          const hit = hitTestResults[0];
          const hitPose = hit.getPose(state.referenceSpace);

          if (hitPose) {
            const position = hitPose.transform.position;
            
            // Place character
            state.character.x = position.x;
            state.character.y = position.y + state.character.size;
            state.character.z = position.z;
            state.characterPlaced = true;
            
            state.character.mesh.visible = true;
            elements.status.classList.remove('hidden');
            elements.controls.classList.remove('hidden');
            elements.crosshair.classList.add('hidden');
            showMessage('Character placed! Use controls to move', 2000);

            // Create surface indicator
            const surfaceGeometry = new THREE.CircleGeometry(0.3, 32);
            const surfaceMaterial = new THREE.MeshBasicMaterial({ 
              color: 0x22c55e,
              transparent: true,
              opacity: 0.3,
              side: THREE.DoubleSide
            });
            const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
            surface.rotation.x = -Math.PI / 2;
            surface.position.set(position.x, position.y, position.z);
            state.scene.add(surface);
            state.surfaceMeshes.push(surface);
            
            state.surfaces.push({
              x: position.x,
              y: position.y,
              z: position.z,
              width: 0.3
            });
          }
        }
      }

      // Update character physics and position
      updateCharacter();
      
      // Update character mesh position
      if (state.character.mesh) {
        state.character.mesh.position.set(
          state.character.x,
          state.character.y,
          state.character.z
        );
        state.character.mesh.rotation.y = state.character.rotation;
      }

      // Render
      state.renderer.render(state.scene, state.camera);
    }

    // Update character physics
    function updateCharacter() {
      const char = state.character;
      const gravity = -0.008;
      const moveSpeed = 0.015;
      const friction = 0.85;

      if (!char.onGround) {
        char.vy += gravity;
      }

      if (state.keysPressed.forward) {
        char.vz -= moveSpeed * Math.cos(char.rotation);
        char.vx -= moveSpeed * Math.sin(char.rotation);
      }
      if (state.keysPressed.backward) {
        char.vz += moveSpeed * Math.cos(char.rotation);
        char.vx += moveSpeed * Math.sin(char.rotation);
      }
      if (state.keysPressed.left) {
        char.rotation += 0.05;
      }
      if (state.keysPressed.right) {
        char.rotation -= 0.05;
      }

      char.x += char.vx;
      char.y += char.vy;
      char.z += char.vz;

      char.vx *= friction;
      char.vz *= friction;

      char.onGround = false;
      for (const surface of state.surfaces) {
        const distToSurface = char.y - char.size - surface.y;
        const horizontalDist = Math.sqrt(
          Math.pow(char.x - surface.x, 2) +
          Math.pow(char.z - surface.z, 2)
        );

        if (Math.abs(distToSurface) < 0.05 && horizontalDist < surface.width && char.vy <= 0) {
          char.y = surface.y + char.size;
          char.vy = 0;
          char.onGround = true;
          char.isJumping = false;
        }

        if (char.onGround && horizontalDist < surface.width * 0.8) {
          state.score = Math.max(state.score, Math.floor(horizontalDist * 100));
          elements.score.textContent = state.score;
        }
      }

      if (char.y < -1) {
        char.y = char.size;
        char.vy = 0;
        char.onGround = true;
      }
    }

    function jump() {
      const char = state.character;
      if (char.onGround && !char.isJumping) {
        char.vy = 0.12;
        char.isJumping = true;
        char.onGround = false;
        showMessage('Jump! ü¶ò', 800);
      }
    }

    function endAR() {
      if (state.session) {
        state.session.end();
        state.session = null;
      }
      state.renderer.setAnimationLoop(null);
      state.arActive = false;
      state.characterPlaced = false;
      state.character.mesh.visible = false;
      
      // Remove surface meshes
      state.surfaceMeshes.forEach(mesh => state.scene.remove(mesh));
      state.surfaceMeshes = [];
      state.surfaces = [];
      
      elements.controls.classList.add('hidden');
      elements.status.classList.add('hidden');
      elements.startSection.classList.remove('hidden');
      elements.instructions.classList.remove('hidden');
      elements.crosshair.classList.add('hidden');
      elements.message.classList.add('hidden');
    }

    // Event listeners
    elements.btnStart.addEventListener('click', startAR);
    elements.btnStop.addEventListener('click', endAR);
    elements.btnJump.addEventListener('click', jump);

    function setupButton(btn, key) {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        state.keysPressed[key] = true;
      });
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        state.keysPressed[key] = false;
      });
      btn.addEventListener('mousedown', () => state.keysPressed[key] = true);
      btn.addEventListener('mouseup', () => state.keysPressed[key] = false);
      btn.addEventListener('mouseleave', () => state.keysPressed[key] = false);
    }

    setupButton(elements.btnForward, 'forward');
    setupButton(elements.btnBackward, 'backward');
    setupButton(elements.btnLeft, 'left');
    setupButton(elements.btnRight, 'right');

    // Initialize
    initThree();
    checkARSupport();
  </script>
</body>
</html>
